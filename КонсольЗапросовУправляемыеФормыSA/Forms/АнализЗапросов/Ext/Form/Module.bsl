#Область ОписаниеПеременных
&НаСервере
Перем ТекущийОператорЗапроса;
&НаСервере
Перем Условия;
&НаСервере
Перем RegExp;  
&НаСервере
Перем КэшЗначений; // Структура
#КонецОбласти

#Область ОбработчикиСобытийФормы

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	Если Параметры.Свойство("Текст") Тогда
		
		Текст = Параметры.Текст;
		ЗаполнитьСтруктуруЗапроса();

	КонецЕсли;
	
	Если Параметры.Свойство("РежимВыбораЧастей") Тогда
		
		Элементы.ФормаОК.Видимость = Ложь;
		Элементы.ФормаПеренестиВыделенные.Видимость = Истина;
		Элементы.ФормаПеренестиВыделенные.КнопкаПоУмолчанию = Истина;
		
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	
	РазвернутьСтруктураЗапроса();
	
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовФормы

&НаКлиенте
Процедура СтуктураЗапросаВыбор(Элемент, ВыбраннаяСтрока, Поле, СтандартнаяОбработка)

	СтандартнаяОбработка = Ложь;
	ТекущиеДанные = Элемент.ТекущиеДанные;
	
	Элементы.Текст.УстановитьГраницыВыделения(ТекущиеДанные.НомерСтрокиНачало
		, 1
		, ТекущиеДанные.НомерСтрокиКонец
		, 150); // TODO посчитать количество символов последней строки.
	
	ТекущийЭлемент = Элементы.Текст;
	
	Если Поле = Элементы.СтуктураЗапросаКоличествоПредупреждений 
		И ТекущиеДанные.КоличествоПредупреждений > 0 Тогда
		
		Если ТекущиеДанные.ЕстьПредупреждение Тогда 
			ПоказатьПредупреждение(,ТекущиеДанные.ТекстПредупреждения);
		Иначе 
			// Спускаемся вниз и сфокусируемся на строке с ошибкой.
			Элемент.Развернуть(ТекущиеДанные.ПолучитьИдентификатор());
			
			Для Каждого СтрокаДерева Из ТекущиеДанные.ПолучитьЭлементы() Цикл
				Если СтрокаДерева.ЕстьПредупреждение Тогда
					Элемент.ТекущаяСтрока = СтрокаДерева.ПолучитьИдентификатор();
					Прервать;
				КонецЕсли;		
			КонецЦикла;	
			
		КонецЕсли;
	
	КонецЕсли;
		 
КонецПроцедуры


#КонецОбласти

#Область ОбработчикиКомандФормы

&НаКлиенте
Процедура ОК(Команда)
	
	Закрыть(Текст);

КонецПроцедуры

&НаКлиенте
Процедура ОбновитьСтруктуруЗапроса(Команда)
	
	ЗаполнитьСтруктуруЗапроса();
	
	РазвернутьСтруктураЗапроса();
		
КонецПроцедуры

&НаКлиенте
Процедура ПеренестиВыделенные(Команда)
	
	МассивЗапросов = Новый Массив;
	
	Для Каждого ИдентификаторСтроки Из Элементы.СтуктураЗапроса.ВыделенныеСтроки Цикл
		
		СтрокаСтруктуры = СтуктураЗапроса.НайтиПоИдентификатору(ИдентификаторСтроки);
		
		СтрокиЗапроса = Новый Массив;
		
		Для Счетчик = СтрокаСтруктуры.НомерСтрокиНачало По СтрокаСтруктуры.НомерСтрокиКонец Цикл
			
			СтрокиЗапроса.Добавить(СтрПолучитьСтроку(Текст, Счетчик));
			
		КонецЦикла;
		
		МассивЗапросов.Добавить(СтрСоединить(СтрокиЗапроса, Символы.ПС));
		
	КонецЦикла;
	
	Закрыть(МассивЗапросов);
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции
&НаСервере
Процедура ЗаполнитьСтруктуруЗапроса();
	
	СхемаЗапроса = Новый СхемаЗапроса;
	СхемаЗапроса.УстановитьТекстЗапроса(Текст);
	
	ТекстФорматированный = СхемаЗапроса.ПолучитьТекстЗапроса();
	Текст = ТекстФорматированный;
	
	Если Найти(Текст,"{") > 0 Тогда // TODO в СхемаЗапроса нет конструкций построителя. Найти способ обойти это. 
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = "Запрос содержит конструкции построителя запроса (фигурные скобки {}). Структура запроса может быть построена неправильно.";
		Сообщение.Сообщить();
	КонецЕсли;
	
	ЭлементыСтуктураЗапроса = СтуктураЗапроса.ПолучитьЭлементы();	
	ЭлементыСтуктураЗапроса.Очистить();
	
	НомерСтроки = 0;
	КоличествоПакетов = СхемаЗапроса.ПакетЗапросов.Количество();
	КоличествоЗапросовПакета = 0;
	
	Для Каждого Пакет Из СхемаЗапроса.ПакетЗапросов Цикл
		
		ВывестиЗапрос(СтуктураЗапроса, Пакет, "Пакет", НомерСтроки, КоличествоПакетов, КоличествоЗапросовПакета);
		
	КонецЦикла;	
	
КонецПроцедуры

Процедура ВывестиЗапрос(ЭлементРодитель, Запрос, ИмяЭлементаЗапроса, НомерСтроки, КоличествоПакетов = 1, КоличествоЗапросовПакета = 0);
	
	НомерСтроки = НомерСтроки + 1;
	ОператорРодитель = ТекущийОператорЗапроса; // Запомним, чтобы вызывающий метод вернулся к своему текущему оператору.
	
	СтрокаЗапрос = ЭлементРодитель.ПолучитьЭлементы().Добавить();
	СтрокаЗапрос.ЭлементЗапроса = ИмяЭлементаЗапроса; 
	СтрокаЗапрос.НомерСтрокиНачало = НомерСтроки;
	
	Если ТипЗнч(Запрос) = Тип("ЗапросУничтоженияТаблицыСхемыЗапроса") Тогда 
		СтрокаЗапрос.ЭлементЗапроса = "Уничтожение";
		СтрокаЗапрос.ЗначениеЭлемента = Запрос.ИмяТаблицы;    
		НомерСтроки = НомерСтроки + 3;
		СтрокаЗапрос.НомерСтрокиКонец = СтрокаЗапрос.НомерСтрокиНачало + 2; 
		Возврат;
	КонецЕсли;
	
	СтрокаЗапрос.ЗначениеЭлемента = ПредставлениеПакета(КоличествоЗапросовПакета, Запрос.ТаблицаДляПомещения); 
	
	НомерОператора 				= 0;
	КоличествоОператоров 		= Запрос.Операторы.Количество();
	КоличествоПолейОператоров 	= Запрос.Колонки.Количество();
	
	Для Каждого ТекущийОператорЗапроса Из Запрос.Операторы Цикл
		
		НомерОператора = НомерОператора + 1;
		
		СтрокаОператор = СтрокаЗапрос.ПолучитьЭлементы().Добавить();
		СтрокаОператор.ЭлементЗапроса = "Запрос";
		СтрокаОператор.ЗначениеЭлемента = Строка(ТекущийОператорЗапроса.ТипОбъединения);
		СтрокаОператор.НомерСтрокиНачало = НомерСтроки;
		
		// ПОЛЯ
		Узел = ДобавитьЭлементСтруктурыЗапроса(НомерСтроки-1,СтрокаОператор,"ВыбираемыеПоля");
		ДополнитьВыбираемыеПоляРекурсивно(НомерСтроки,Узел,ТекущийОператорЗапроса.ВыбираемыеПоля);
		
		КоличествоПолейТекущегоОператора = ТекущийОператорЗапроса.ВыбираемыеПоля.Количество();
		
		// Дополним поля NULL
		Для Счетчик = КоличествоПолейТекущегоОператора По КоличествоПолейОператоров-1 Цикл 
			ДобавитьЭлементСтруктурыЗапроса(НомерСтроки,Узел, "Поле", "NULL");
		КонецЦикла;
		
		Узел.НомерСтрокиКонец = НомерСтроки;
		
		// ВРЕМЕННАЯ ТАБЛИЦА
		Если НомерОператора = 1
			И Не ПустаяСтрока(Запрос.ТаблицаДляПомещения) Тогда
			НомерСтроки = НомерСтроки + 1;
		КонецЕсли;
		
		// ИСТОЧНИКИ
		ДобавитьИсточники(НомерСтроки, СтрокаОператор, ТекущийОператорЗапроса);
		
		// ОТБОР
		ДобавитьПодчиненныйУзел(НомерСтроки, СтрокаОператор, ТекущийОператорЗапроса, "Отбор");
		
		// ГРУППИРОВКА
		УвеличитьСчетчикСтрокПередКлючевымСловом(НомерСтроки, ТекущийОператорЗапроса.Группировка);
		ДобавитьПодчиненныйУзел(НомерСтроки, СтрокаОператор, ТекущийОператорЗапроса,"Группировка");
			
		СтрокаОператор.НомерСтрокиКонец = НомерСтроки;
		
		Если КоличествоОператоров > 1 
			И НомерОператора <> КоличествоОператоров Тогда // Разделитель операторов
			НомерСтроки = НомерСтроки + 4;
		КонецЕсли;
		
	КонецЦикла;
	
	// ПОРЯДОК
	УвеличитьСчетчикСтрокПередКлючевымСловом(НомерСтроки,Запрос.Порядок);
	ДобавитьПодчиненныйУзел(НомерСтроки,СтрокаЗапрос,Запрос,"Порядок");
	
	// ИНДЕКСЫ
	УвеличитьСчетчикСтрокПередКлючевымСловом(НомерСтроки, Запрос.Индекс);
	ДобавитьПодчиненныйУзел(НомерСтроки, СтрокаЗапрос, Запрос, "Индекс");
	
	// ИТОГИ
	ДобавитьПодчиненныйУзел(НомерСтроки,СтрокаЗапрос,Запрос,"КонтрольныеТочкиИтогов");
	
	СтрокаЗапрос.НомерСтрокиКонец = НомерСтроки;
	
	Если КоличествоПакетов > 1 Тогда // Разделитель пакетов
		НомерСтроки = НомерСтроки + 3;
	КонецЕсли;
	
	ТекущийОператорЗапроса = ОператорРодитель;
	
КонецПроцедуры
	
Процедура ДополнитьВыбираемыеПоляРекурсивно(НомерСтроки, Узел, Коллекция);
	
	Для Каждого Поле Из Коллекция Цикл
		
		Если ТипЗнч(Поле) = Тип("ВложеннаяТаблицаСхемыЗапроса") Тогда
			НовыйУзел = ДобавитьЭлементСтруктурыЗапроса(НомерСтроки, Узел, "ВложенныеПоля"); 
			ДополнитьВыбираемыеПоляРекурсивно(НомерСтроки, НовыйУзел, Поле.Поля);	
			НомерСтроки = НомерСтроки + 1; // Строка псевдонима вложенных полей
			НовыйУзел.НомерСтрокиКонец = НомерСтроки;
		Иначе
			ДобавитьЭлементСтруктурыЗапроса(НомерСтроки, Узел, "Поле", Поле);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры
		
Функция ДобавитьЭлементСтруктурыЗапроса(НомерСтроки, Родитель, ЭлементЗапроса, Значение = Неопределено, Псевдоним = "")
	
	КоличествоСтрок = 1;
	СтарыйНомерСтроки = НомерСтроки;
	ПредставлениеЗначения = Строка(Значение);
	
	Если Не ПустаяСтрока(ПредставлениеЗначения) Тогда
		КоличествоСтрок = СтрРазделить(ПредставлениеЗначения, Символы.ПС).Количество();
	КонецЕсли;
	
	НомерСтроки = НомерСтроки + КоличествоСтрок; // Увеличим счетчик строк
		
	Строка = Родитель.ПолучитьЭлементы().Добавить();
	Строка.ЭлементЗапроса = ЭлементЗапроса;
	Строка.ЗначениеЭлемента = Значение;   
	Строка.Псевдоним = Псевдоним;
	
	Строка.НомерСтрокиНачало = СтарыйНомерСтроки + 1;	
	Строка.НомерСтрокиКонец = НомерСтроки;
	
	ПроверитьЭлемент(Строка, ЭлементЗапроса, Значение);
	
	Возврат Строка;
	
КонецФункции

Функция ДобавитьПодчиненныйУзел(НомерСтроки, Родитель, ЭлементСхемы, ИмяУзла);
	
	Если ЭлементСхемы[ИмяУзла].Количество() = 0 Тогда
		Возврат Ложь
	КонецЕсли;
	
	Узел = ДобавитьЭлементСтруктурыЗапроса(НомерСтроки,Родитель,ИмяУзла);
	Коллекция = ЭлементСхемы[ИмяУзла];
	
	Для Каждого Элемент Из Коллекция Цикл
		ДобавитьЭлементСтруктурыЗапроса(НомерСтроки, Узел, "Поле" + ИмяУзла, Элемент);	
	КонецЦикла;
	
	Узел.НомерСтрокиКонец = НомерСтроки; 
	
	Возврат Истина;
	
КонецФункции

Функция ДобавитьИсточники(НомерСтроки, Родитель, Оператор);
	
	Если Оператор.Источники.Количество() = 0 Тогда
		Возврат Ложь
	КонецЕсли;
	
	Узел = ДобавитьЭлементСтруктурыЗапроса(НомерСтроки, Родитель, "Источники");
	Коллекция = Оператор.Источники;
	
	МассивИсточников = Новый Массив;
	
	Для Каждого Источник Из Коллекция Цикл
		
		ПсевдонимТаблицы = Источник.Источник.Псевдоним;
		
		Если МассивИсточников.Найти(ПсевдонимТаблицы) <> Неопределено Тогда
			Продолжить; // Источник уже добавлен
		КонецЕсли;
				
		МассивИсточников.Добавить(ПсевдонимТаблицы);

		Если ТипЗнч(Источник.Источник) = Тип("ВложенныйЗапросСхемыЗапроса") Тогда
			ВывестиЗапрос(Узел, Источник.Источник.Запрос, "ВложенныйЗапрос", НомерСтроки);
			Продолжить;
		КонецЕсли;

		УзелИсточника = ДобавитьЭлементСтруктурыЗапроса(НомерСтроки, Узел, "Источник", Источник.Источник.ИмяТаблицы, Источник.Источник.Псевдоним);
		
		Если Тип(Источник.Источник) = Тип("ТаблицаСхемыЗапроса") Тогда
			Для Каждого Параметр Из Источник.Источник.Параметры Цикл  
				ДобавитьЭлементСтруктурыЗапроса(НомерСтроки, УзелИсточника, "Параметр", Параметр.Выражение);
			КонецЦикла;  
			ДобавитьИндексы(УзелИсточника, Источник.Источник.ИмяТаблицы); 
		КонецЕсли;
		
		Если Источник.Соединения.Количество() > 0 Тогда
			
			УзелСоединений = ДобавитьЭлементСтруктурыЗапроса(НомерСтроки, УзелИсточника, "Соединения");
			НомерСтроки = НомерСтроки - 1;
			
			ДобавитьСоединения(НомерСтроки, Узел, УзелСоединений, МассивИсточников, Источник.Соединения);
			УзелСоединений.НомерСтрокиКонец = НомерСтроки;
			
		КонецЕсли;	
					
	КонецЦикла;
	
	Узел.НомерСтрокиКонец = НомерСтроки; 
	
	Возврат Истина;
	
КонецФункции

Функция ДобавитьСоединения(НомерСтроки,УзелИсточников,УзелСоединений,МассивИсточников,Соединения);
	
	Если Соединения.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого Соединение Из Соединения Цикл
			
		ПсевдонимТаблицыСоединения = Соединение.Источник.Источник.Псевдоним;
		
		Если МассивИсточников.Найти(ПсевдонимТаблицыСоединения) = Неопределено Тогда
			
			МассивИсточников.Добавить(ПсевдонимТаблицыСоединения);
			
			Если ТипЗнч(Соединение.Источник.Источник) = Тип("ВложенныйЗапросСхемыЗапроса") Тогда
				ВывестиЗапрос(УзелИсточников,Соединение.Источник.Источник.Запрос,"ВложенныйЗапрос",НомерСтроки);
			Иначе
				ДобавитьЭлементСтруктурыЗапроса(НомерСтроки, УзелИсточников, "Источник", Соединение.Источник.Источник.ИмяТаблицы);
			КонецЕсли;

		КонецЕсли;

		ДобавитьСоединения(НомерСтроки,УзелИсточников,УзелСоединений,МассивИсточников,Соединение.Источник.Соединения);

		ДобавитьЭлементСтруктурыЗапроса(НомерСтроки,УзелСоединений, "УсловиеСоединения", Соединение.Условие);
		
	КонецЦикла;
	
	Возврат Истина;
			
КонецФункции

Функция УвеличитьСчетчикСтрокПередКлючевымСловом(НомерСтроки, Коллекция);
	
	Если Коллекция.Количество() > 0 Тогда
		НомерСтроки = НомерСтроки + 1;
		Возврат Истина;	
	Иначе
		Возврат Ложь;	
	КонецЕсли;
	
КонецФункции

Функция ПредставлениеПакета(КоличествоЗапросовПакета, ТаблицаДляПомещения)

	Если ПустаяСтрока(ТаблицаДляПомещения) Тогда
		КоличествоЗапросовПакета = КоличествоЗапросовПакета + 1;
		Возврат "Запрос пакета " + КоличествоЗапросовПакета;
	Иначе
		Возврат ТаблицаДляПомещения;
	КонецЕсли;

КонецФункции

Функция ПроверитьЭлемент(СтрокаДерева, ЭлементЗапроса, Значение)
	
	Если Значение = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("ВыражениеСхемыЗапроса") Тогда
		ПроверитьВыражениеСхемыЗапроса(СтрокаДерева, ЭлементЗапроса, Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("ВыражениеПорядкаСхемыЗапроса") Тогда 
		ПроверитьВыражениеСхемыЗапроса(СтрокаДерева, ЭлементЗапроса, Значение.Элемент);
	ИначеЕсли ТипЗнч(Значение) = Тип("ВыражениеИндексаСхемыЗапроса") Тогда 
		ПроверитьВыражениеСхемыЗапроса(СтрокаДерева, ЭлементЗапроса, Значение.Выражение);
	КонецЕсли;

	Возврат Истина;
	
КонецФункции

Процедура ПроверитьВыражениеСхемыЗапроса(СтрокаДерева, ЭлементЗапроса, Значение);
		
	СтруктураВыражения = РазобратьВыражениеСхемыЗапроса(Значение); 
	
	ПроверитьНаПолучениеДанныхЧерезТочку(СтрокаДерева, СтруктураВыражения.Поля); 
	Если ЭлементЗапроса = "ПолеОтбор" Тогда
		ПроверитьНаНаличиеИндекса(СтрокаДерева, СтруктураВыражения.Поля);
	КонецЕсли;

КонецПроцедуры

Функция РазобратьВыражениеСхемыЗапроса(Значение)
	
	Строка = Строка(Значение);
	
	СтруктураВыражения = Новый Структура("Поля,Параметры,Условия,Выражения,Запросы",
		ПолучитьМассивСовпадений(Строка,"[\wа-яА-ЯёЁ]+([.][\wа-яА-ЯёЁ]+)+"),//"\w+[.]\w+"),
		ПолучитьМассивСовпадений(Строка,"&[\wа-яА-ЯёЁ]"), //"&\w+"
		Новый Массив,
		Новый Массив,
		Новый Массив);
		
	// Поля 	
	Возврат СтруктураВыражения;
	
КонецФункции

Процедура ПроверитьНаПолучениеДанныхЧерезТочку(СтрокаДерева, МассивПолей);
	
	// Разыменование ссылочных полей составного типа в языке запросов.
	// https://its.1c.ru/db/v8std#content:654:hdoc
	
	Для Каждого Значение Из МассивПолей Цикл
		
		МассивЭлементовПоля = СтрРазделить(Значение, "."); 
		
		Если МассивЭлементовПоля.Количество() < 2 Тогда
			// Нет получения данных через точку.
			Продолжить;			
		КонецЕсли;	
		
		ИсточникДанных = ТекущийОператорЗапроса.Источники.НайтиПоПсевдониму(МассивЭлементовПоля[0]);
		
		Если ИсточникДанных = Неопределено Тогда
			Продолжить;			
		КонецЕсли;
		
		ТекущееПолеСхемыЗапроса = ИсточникДанных.Источник.ДоступныеПоля.Найти(МассивЭлементовПоля[1]);
		
		Если ТипЗнч(ТекущееПолеСхемыЗапроса) = Тип("ДоступнаяВложеннаяТаблицаСхемыЗапроса") Тогда
			Продолжить; // TODO предусмотреть обработку вложенных полей. 
		КонецЕсли;
		
		ТекущееКоличествоТипов = ТекущееПолеСхемыЗапроса.ТипЗначения.Типы().Количество();
		
		Для НомерЭлемента = 2 По МассивЭлементовПоля.Количество()-1 Цикл
			
			Если ТекущееКоличествоТипов > 1 Тогда
				ВывестиПредупреждение(СтрокаДерева, "Получение данных через точку от составного типа, поле " + ТекущееПолеСхемыЗапроса.Имя);
			КонецЕсли;
			
			ТекущееПолеСхемыЗапроса = ТекущееПолеСхемыЗапроса.Поля.Найти(МассивЭлементовПоля[НомерЭлемента]);
			
			Если ТекущееПолеСхемыЗапроса = Неопределено Тогда 
				Прервать;
			КонецЕсли;
			
			ТекущееКоличествоТипов = ТекущееПолеСхемыЗапроса.ТипЗначения.Типы().Количество();
			
		КонецЦикла;
		
		// Проверка на получение ссылки из самой ссылки
		Если Найти(НРег(Значение), "ссылка.ссылка") > 0 Тогда
			ВывестиПредупреждение(СтрокаДерева, "Получение ссылки на объект из самой ссылки");
		КонецЕсли;
		
	КонецЦикла;

КонецПроцедуры

Процедура ПроверитьНаНаличиеИндекса(СтрокаДерева, МассивПолей);
	
	// 1. Перейдем в источники, где и будем искать индексы  
	ЭлементыЗапроса = СтрокаДерева.ПолучитьРодителя().ПолучитьРодителя().ПолучитьЭлементы();
	Для Каждого Узел Из ЭлементыЗапроса Цикл  
		Если Узел.ЭлементЗапроса = "Источники" Тогда 
			Источники = Узел.ПолучитьЭлементы();
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Источники = Неопределено Тогда
		Возврат
	КонецЕсли;
	
	//Источники = СтрокаДерева.ПолучитьРодителя().ПолучитьРодителя().ПолучитьЭлементы()[1].ПолучитьЭлементы();
	
	Для Каждого ПроверяемоеПоле Из МассивПолей Цикл
		
		// 2. Перейдем в источник этого поля, поиск по псвевдониму
		ЧастиПоля = СтрРазделить(ПроверяемоеПоле, ".");
		ПсевдонимТаблицы = ЧастиПоля[0];
		ИмяПоля = ЧастиПоля[1];
			
		Для Каждого УзелИсточника Из Источники Цикл  
			Если УзелИсточника.Псевдоним = ПсевдонимТаблицы Тогда
				 Прервать;
			КонецЕсли;
		КонецЦикла;
		
		// 3. Если в таблице меньше 100 записей, то не будем анализировать индексы.
		КоличествоЗаписейТаблицы = КоличествоЗаписейТаблицы(УзелИсточника.ЗначениеЭлемента);
		Если КоличествоЗаписейТаблицы < 100 Тогда
			Продолжить;
		КонецЕсли;
		
		// 4. Простая проверка - есть хотя бы в одном из индексов это поле. TODO продумать более сложные случаи.
		Индексы = УзелИсточника.Индексы.ПолучитьЭлементы(); 
		ПолеЕстьВИндексах = Ложь;
		Для Каждого Индекс Из Индексы Цикл  
			Для Каждого Поле Из Индекс.ПолучитьЭлементы() Цикл   
				Если Поле.ИмяПоля = ИмяПоля Тогда  
					ПолеЕстьВИндексах = Истина;
					Прервать;
				КонецЕсли;	
			КонецЦикла;
		КонецЦикла;
		
		// 5. Выводим предупреждение
		Если Не ПолеЕстьВИндексах Тогда  
			ВывестиПредупреждение(СтрокаДерева, "Поля нет ни в одном индексе");
		КонецЕсли;
		
	КонецЦикла;

КонецПроцедуры

Функция ПолучитьМассивСовпадений(String, Pattern)
	
	ResultArr = New Array;
	
	RegExp.Pattern = Pattern;
	Matches = RegExp.Execute(String);

	If Matches.Count = 0 Then
		Return ResultArr;
	EndIf;
	
	For Item = 0 To Matches.Count - 1 Do 
		ResultArr.Add(Matches.Item(Item).Value);	
	EndDo;
	
	Return ResultArr;
	
КонецФункции

Процедура ВывестиПредупреждение(СтрокаДерева, ТекстСообщения)
	
	СтрокаДерева.ЕстьПредупреждение = Истина;
	
	Если СтрокаДерева.КоличествоПредупреждений > 0 Тогда
		СтрокаДерева.ТекстПредупреждения = СтрокаДерева.ТекстПредупреждения + Символы.ПС;
	КонецЕсли;
	
	СтрокаДерева.ТекстПредупреждения = СтрокаДерева.ТекстПредупреждения + ТекстСообщения;
	СтрокаДерева.КоличествоПредупреждений = СтрокаДерева.КоличествоПредупреждений + 1;
	
	Родитель = СтрокаДерева.ПолучитьРодителя();
	Родитель.КоличествоПредупреждений = Родитель.КоличествоПредупреждений + 1;
	
	Родитель = Родитель.ПолучитьРодителя();
	Родитель.КоличествоПредупреждений = Родитель.КоличествоПредупреждений + 1;

КонецПроцедуры	

&НаКлиенте
Процедура РазвернутьСтруктураЗапроса()
	
	ЭлементыСтрутктуры = СтуктураЗапроса.ПолучитьЭлементы();
	
	Если ЭлементыСтрутктуры.Количество() > 10 Тогда
		Возврат; // Не будем разворачивать, т.к. не войдет в экран.
	КонецЕсли;
	
	Для Каждого СтрокаПакет Из ЭлементыСтрутктуры Цикл
		
		Элементы.СтуктураЗапроса.Развернуть(СтрокаПакет.ПолучитьИдентификатор());
		
		Если ЭлементыСтрутктуры.Количество() > 2 Тогда
			Продолжить;
		КонецЕсли;
		
		// Развернем второй уровень, если всего не более 2х запросов. 
		Для Каждого СтрокаОператор Из СтрокаПакет.ПолучитьЭлементы() Цикл		
			Элементы.СтуктураЗапроса.Развернуть(СтрокаОператор.ПолучитьИдентификатор());		
		КонецЦикла;
		
	КонецЦикла;

КонецПроцедуры
 
&НаСервере
Процедура ДобавитьИндексы(СтрокаДерева, Знач ИмяТаблицы)
	
	МассивПодстрок = СтрРазделить(ИмяТаблицы, ".");
	
	Если МассивПодстрок.Количество() < 2 Тогда // Это вложенный запрос или временная таблица. TODO запоминать это при заполнении дерева, для временных таблиц можно запоминать индексы.
		Возврат;
	ИначеЕсли МассивПодстрок.Количество() = 3 
		И СтрНачинаетсяС(ИмяТаблицы, "Регистр") Тогда // ВиртуальнаяТаблица  
		ИмяТаблицы = МассивПодстрок[0] + "." + МассивПодстрок[1]; 				
	КонецЕсли;
		
	Массив = Новый Массив;
	Массив.Добавить(ИмяТаблицы);
	
	СтруктураХранения = ПолучитьСтруктуруХраненияБазыДанных(Массив);
	
	Индексы = СтруктураХранения.НайтиСтроки(Новый Структура("ИмяТаблицы", ИмяТаблицы))[0].Индексы;
	
	Для Каждого Индекс Из Индексы Цикл
		
		СтрокаИндекса = СтрокаДерева.Индексы.ПолучитьЭлементы().Добавить();
		СтрокаИндекса.ИмяИндексаХранения = Индекс.ИмяИндексаХранения; 
		
		Для Каждого Поле Из Индекс.Поля Цикл
			ЗаполнитьЗначенияСвойств(СтрокаИндекса.ПолучитьЭлементы().Добавить(), Поле);	
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

Функция КоличествоЗаписейТаблицы(ИмяТаблицы) 
	
	Если СтрНайти(ИмяТаблицы, ".") = 0 Тогда // Временная таблица
		Возврат 0;
	КонецЕсли;
	
	Если КэшЗначений = Неопределено Тогда    
		КэшЗначений = Новый Структура
	КонецЕсли;

	Если Не КэшЗначений.Свойство("КоличествоЗаписейТаблиц") Тогда
		КэшЗначений.Вставить("КоличествоЗаписейТаблиц", Новый Соответствие);
	КонецЕсли;
	
	Значение = КэшЗначений.КоличествоЗаписейТаблиц.Получить(ИмяТаблицы);
	Если Значение = Неопределено Тогда
		Запрос = Новый Запрос("ВЫБРАТЬ КОЛИЧЕСТВО(1) КАК Количество ИЗ " + ИмяТаблицы + " КАК Таблица");
		РезультатЗапроса = Запрос.Выполнить();
		Выборка = РезультатЗапроса.Выбрать(); 
		Выборка.Следующий(); 
		Значение = Выборка.Количество;
		КэшЗначений.КоличествоЗаписейТаблиц.Вставить(ИмяТаблицы, Значение);  
	КонецЕсли;

	Возврат Значение;
	
КонецФункции

#КонецОбласти

#Область Удалить

&НаСервере
Процедура ПоказатьИндексы(ИмяТаблицы)
	
	//МассивПодстрок = СтрРазделить(ИмяТаблицы, ".");
	//
	//Если МассивПодстрок.Количество() < 2 Тогда // Это вложенный запрос или временная таблица. TODO запоминать это при заполнении дерева, для временных таблиц можно запоминать индексы.
	//	Возврат;
	//ИначеЕсли МассивПодстрок.Количество() = 3 Тогда // ВиртуальнаяТаблица  
	//	ИмяТаблицы = МассивПодстрок[0] + "." + МассивПодстрок[1]; 				
	//КонецЕсли;
	//	
	//Массив = Новый Массив;
	//Массив.Добавить(ИмяТаблицы);
	//
	//СтруктураХранения = ПолучитьСтруктуруХраненияБазыДанных(Массив);
	//
	//Индексы = СтруктураХранения.НайтиСтроки(Новый Структура("ИмяТаблицы", ИмяТаблицы))[0].Индексы;
	//
	//Для Каждого Индекс Из Индексы Цикл
	//	
	//	СтрокаИндекса = ДеревоИндексов.ПолучитьЭлементы().Добавить();
	//	СтрокаИндекса.ИмяИндексаХранения = Индекс.ИмяИндексаХранения; 
	//	
	//	Для Каждого Поле Из Индекс.Поля Цикл
	//		ЗаполнитьЗначенияСвойств(СтрокаИндекса.ПолучитьЭлементы().Добавить(),Поле);	
	//	КонецЦикла;
	//	
	//КонецЦикла;
	//
КонецПроцедуры

&НаКлиенте
Процедура СтуктураЗапросаПриАктивизацииСтроки(Элемент)
	
	//ДеревоИндексов.ПолучитьЭлементы().Очистить();
	//
	//ТекущиеДанные = Элемент.ТекущиеДанные;
	//
	//Если ТекущиеДанные = Неопределено Тогда 
	//	Возврат
	//КонецЕсли;
	//
	//Если ТекущиеДанные.ЭлементЗапроса = "Источник" Тогда
	//	Попытка
	//		ПоказатьИндексы(ТекущиеДанные.ЗначениеЭлемента);	
	//	Исключение
	//		Сообщить(ОписаниеОшибки());
	//	КонецПопытки;
	//КонецЕсли;
	
КонецПроцедуры

#КонецОбласти 

#Область Инициализация
RegExp = Новый COMОбъект("VBScript.RegExp");

Условия = Новый Массив;
Условия.Добавить(">");
Условия.Добавить("<");
Условия.Добавить("<>");
Условия.Добавить("=");
Условия.Добавить(">=");
Условия.Добавить("<=");
Условия.Добавить("ПОДОБНО");
#КонецОбласти

